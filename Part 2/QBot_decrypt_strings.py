import idc
import idautils
from qiling import *

######################################## IDAPython ########################################

# start/end of the decryption function
DEC_START = 0x4065B7
DEC_END   = 0x406655

# xrefs to the decryption function
xrefs = idautils.CodeRefsTo(DEC_START, 0)
# indexes of requested strings to decrypt
indexes = {}

for x in xrefs:
    # address of previous instruction where "eax" is set
    ea = idc.prev_head(x)
    # type of the second operand of "mov"
    t = idc.get_operand_type(ea, 1)
    # check if the second operand is an immediate (not dynamic value)
    if t == idc.o_imm:
        # get the index value (second operand)
        idx = idc.get_operand_value(ea, 1)
        indexes[ea] = idx

####################################### Qiling ############################################

# initialize emulator (x86 windows)
ql = Qiling(["qbot.exe"], rootfs="qiling/examples/rootfs/x86_windows")

# read string from memory address
def readString(ql, addr):
    res = ""
    while True:
        # read one byte at a time
        c = ql.mem.read(addr, 1).decode()
        if c == '\x00':
            break
        res += c
        addr += 1
    return res

# loop through collected indexes
for ea, idx in indexes.items():
    # set function parameter "eax"
    ql.reg.eax = idx
    # run decryption function
    ql.run(begin=0x4065B7, end=0x406654)
    # set decrypted string as ida comment
    idc.set_cmt(ea, readString(ql, ql.reg.eax), 1)
